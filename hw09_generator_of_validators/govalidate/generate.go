package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

type TemplateField struct {
	Name   string
	Type   string
	Regexp string
	Len    string
	Max    string
	Min    string
	In     string
}

type TemplateStruct struct {
	Name   string
	Fields []TemplateField
}

func normalizeType(currType string) (string, error) {
	normalTypes := []string{"int", "string", "[]int", "[]string"}
	for _, n := range normalTypes {
		if currType == n {
			return currType, nil
		}
	}
	for userType, usualType := range Types {
		if userType == currType {
			return usualType, nil
		}
	}
	return "", fmt.Errorf("unknown type %s", currType) //nolint
}

var validate = `func (t {{ .Name }}) Validate() ([]ValidationError, error) {
  validErrs := []ValidationError{}
  {{ range .Fields}}

  {{- if (eq .Type "int")}}
  {{ template "intValidate" . }}
  {{- end }}

  {{- if (eq .Type "string")}}
  {{ template "stringValidate" . }}
  {{- end }}

  {{- if (eq .Type "[]int")}}
  for i, _ := range t.{{ .Name }} {
    {{ $new := arrayElement . }}
    {{ template "stringValidate" $new }}
  }
  {{- end }}

  {{- if (eq .Type "[]string")}}
  for i, _ := range t.{{ .Name }} {
    {{ $new := arrayElement . }}
    {{ template "stringValidate" $new }}
  }
  {{- end }}

  {{ end }}
  return validErrs, nil
}
`

var intValidate = `{{- if (ne .Min "")}}

if t.{{.Name}} < {{.Min}} {
  validErrs = append(validErrs, ValidationError{
    Field: "{{.Name}}",
    Err: fmt.Errorf("less than min"),
  })
}

{{- end }}

{{- if (ne .Max "")}}

if t.{{.Name}} > {{.Max}} {
  validErrs = append(validErrs, ValidationError{
    Field: "{{.Name}}",
    Err: fmt.Errorf("more than max"),
  })
}

{{- end }}

{{- if (ne .In "")}}

intVariants := []int{ {{.In}} }
isVariant := false
for _, i := range intVariants {
  if t.{{.Name}} == i {
    isVariant = true
    break
  }
}
if !isVariant {
  validErrs = append(validErrs, ValidationError{
    Field: "{{.Name}}",
    Err: fmt.Errorf("not allowed value"),
  })
}

{{- end }}
`

var stringValidate = `{{- if (ne .In "")}}

strVariants := []string{ {{.In}} }
isStrVariant := false
for _, i := range strVariants {
  if string(t.{{.Name}}) == i {
    isStrVariant = true
    break
  }
}
if !isStrVariant {
  validErrs = append(validErrs, ValidationError{
    Field: "{{.Name}}",
    Err: fmt.Errorf("not allowed value"),
  })
}

{{- end }}

{{- if (ne .Len "")}}

if len(t.{{.Name}}) != {{.Len}} {
  validErrs = append(validErrs, ValidationError{
    Field: "{{.Name}}",
    Err: fmt.Errorf("wrong length"),
  })
}

{{- end }}

{{- if (ne .Regexp "")}}

matched, err := regexp.MatchString({{ .Regexp }}, t.{{.Name}})
if err != nil {
  return validErrs, fmt.Errorf("wrong regexp")
}
if !matched {
  validErrs = append(validErrs, ValidationError{
    Field: "{{.Name}}",
    Err: fmt.Errorf("does not match regexp"),
  })
}

{{- end }}
`

func generate(path string) error {
	t, err := template.New("validate").Funcs(template.FuncMap{
		"arrayElement": func(field TemplateField) TemplateField {
			field.Type = strings.Split(field.Type, "[]")[1]
			field.Name += "[i]"
			return field
		},
	}).Parse(validate)
	if err != nil {
		return err
	}

	_, err = t.New("intValidate").Parse(intValidate)
	if err != nil {
		return err
	}

	_, err = t.New("stringValidate").Parse(stringValidate)
	if err != nil {
		return err
	}

	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	beginning := `// Code generated by go-validate. DO NOT EDIT.
package models

import (
  "fmt"
  "regexp"
)

type ValidationError struct{
  Field string
  Err   error
}

`
	_, err = file.Write([]byte(beginning))
	if err != nil {
		return err
	}

	for _, s := range structsToValidate {
		err = t.ExecuteTemplate(file, "validate", s)
		if err != nil {
			return err
		}
	}
	return nil
}
